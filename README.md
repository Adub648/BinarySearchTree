# Binary Search Tree

An algorithm that generates a binary search tree and has various methods that change values within the tree and check if the tree matches set conditions.

Pre-set instructions in code do as follows:

1. Create a binary search tree from an array of random numbers `(Array.new(15) { rand(1..100) })`
2. Confirm that the tree is balanced by calling `#balanced?`
3. Print out all elements in level, pre, post, and in order
4. Unbalance the tree by adding several numbers > 100
5. Confirm that the tree is unbalanced by calling `#balanced?`
6. Balance the tree by calling `#rebalance`
7. Confirm that the tree is balanced by calling `#balanced?`
8. Print out all elements in level, pre, post, and in order

Methods not included in pre-set instructions include:
- `insert` and `delete` to insert and delete values
- `find` to return node with given value
- `height` which returns the height of a node (length to a leaf node)
- `depth` which returns the depth of a node (length from root to node)

# What I struggled with
While I understood how to implement the majority of this code (due to doing the linked list project) the scope of some of the methods that we were required to make (and how they spawned seperate methods in themselves) was above and beyond what I had done before and it was definitely a struggle at times. However, over time I was able to understand more and more pieces of the project and through undertaking research as well as through my own knowledge I was able to slowly buy surely add and complete methods as I went along, which ultimately led to the completion of this task. I think that I am really starting to "get" some of these concepts, which is definitely going to help me in future projects.